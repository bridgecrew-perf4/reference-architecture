# Chalice

[AWS Chalice](https://aws.github.io/chalice/index.html) is a microframework for writing serverless applications using Python.

## Summary
This is leaner, purpose built [Flask-esque](https://flask.palletsprojects.com/en/2.0.x/) framework for using Python with serverless.

Chalice is an exciting microframework, because it fills a special niche between heavy tooling that tries to do everything (and thus provides a lot of magic you may not understand and may have to figure out once a feature you need is unsupported [e.g. Serverless Framework]) and no tool at all (which forces you to do everything manually).  It solves a lot of fundamental problems you encounter when working with serverless offerings from AWS:

- No local development environment for Lambda
- No easy way to see Lambda stack traces outside of CloudWatch Logs
- No way to define middleware per AWS service

With a little more [upfront strategic thought](https://alexkrupp.typepad.com/sensemaking/2021/06/django-for-startup-founders-a-better-software-architecture-for-saas-startups-and-consumer-apps.html) on how to use it, I would recommend we expand the pilot.  

## Questions
- How mature is AWS Chalice?
- Is it ready to be used in Production?
- How does it fit into our new S3 static website + API Gateway + Lambda strategy?

## Answers


## Bright Spots

### Local Development
![Local Development Console](/img/chalice-local-dev-very-nice-1.png)
![Local Development Browser](/img/chalice-local-dev-very-nice-2.png)

### Friendly Error Messages
![Friendly Error Console](/img/chalice-passing-friendly-error-messages-1.png)
![Friendly Error Code](/img/chalice-passing-friendly-error-messages-2.png)

### Middleware
You can register middleware per type of event handlers with options like s3, sns, sqs, cloudwatch, which is a great idea.  Imagine being able to uniformly transform all of the messages being passed to and from an SNS topic.

## Head Scratchers
Here's a list of shortcomings from Chalice:

### Terraform Support
Chalice does support exporting to Terraform, but even after a short while using ```chalice deploy``` you probably will start to wonder: why use Terraform at all?  The ergonomics of ```chalice deploy``` are nothing short of fantastic.

Here's an example Lambda resource that was auto-generated by Chalice:
```hcl
"aws_lambda_function": {
    "api_handler": {
    "function_name": "test-tf-deploy-dev",
    "runtime": "python3.8",
    "handler": "app.app",
    "memory_size": 128,
    "tags": {
        "aws-chalice": "version=1.24.0:stage=dev:app=test-tf-deploy"
    },
    "timeout": 60,
    "source_code_hash": "${filebase64sha256(\"${path.module}/deployment.zip\")}",
    "filename": "${path.module}/deployment.zip",
    "role": "${aws_iam_role.default-role.arn}"
    }
},
```